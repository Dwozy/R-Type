<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-Type: Game Engine documentation and usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">R-Type
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Game Engine documentation and usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Entity Component System</h1>
<p>The Entity Component System is the core of the game engine, it will manage every entity and their components, and will update them with the systems.</p>
<p>The Components and Systems needs to be registered in the registry contained in the game engine.</p>
<p>The game engine already have some components and systems, but more can be created.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Components</h2>
<p>Components are <code>struct</code> that contains datas for the entities. They can be added to the registry using the <code>RegisterComponent</code> method. To add them to an entity, use the <code>AddComponent</code> method. The components are stored in <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>s, these arrays store the components and can have empty indexes. Use the <code>getComponent</code> method of the registry to retrieve the array. Before using an index, you need to verify that the index have a value : </p><div class="fragment"><div class="line"><a class="code" href="classSparseArray.html">SparseArray&lt;int&gt;</a> &amp;intArray = registry.getComponent&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (intArray[i])</div>
<div class="line">    <span class="comment">/// Use the value</span></div>
<div class="ttc" id="aclassSparseArray_html"><div class="ttname"><a href="classSparseArray.html">SparseArray</a></div><div class="ttdoc">Array which can have empty indexes.</div><div class="ttdef"><b>Definition:</b> SparseArray.hpp:19</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3"></a>
Camera component</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">View   </td><td class="markdownTableBodyNone"><a class="el" href="classGameEngine_1_1View.html" title="Class representing a view wrapper for sf::View.">GameEngine::View</a>   </td><td class="markdownTableBodyNone">Will be used as the view for the window, needs to be set to it. It will define the scale of the camera.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md4"></a>
Collision component</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">collider   </td><td class="markdownTableBodyNone"><a class="el" href="namespaceGameEngine.html#a48bc9a7e4a2df9c490fb201f4211a676">GameEngine::Rectf</a>   </td><td class="markdownTableBodyNone">Hitbox for the collision, the shape is a rect, and his position is based on the position in the transform component.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">actions   </td><td class="markdownTableBodyNone">std::vector&lt;std::function&lt;void(const std::size_t &amp;entityId)&gt;&gt;   </td><td class="markdownTableBodyNone">Vector storing the collision callbacks. They can be added using the <code>addAction</code> method    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">layer   </td><td class="markdownTableBodyNone">std::size_t   </td><td class="markdownTableBodyNone">Defines the layer of the collision, so the callbacks can be with only a certain layer of collisions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">isActive   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Tells if the collision is active.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md5"></a>
ControllableComponent</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">key_up   </td><td class="markdownTableBodyNone"><a class="el" href="namespaceGameEngine_1_1Input_1_1Keyboard.html#ae7a13060cb2848c5bb8efa7c9f71cbac">GameEngine::Input::Keyboard::Key</a>   </td><td class="markdownTableBodyNone">Store the key which will be used to go up.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">key_left   </td><td class="markdownTableBodyNone"><a class="el" href="namespaceGameEngine_1_1Input_1_1Keyboard.html#ae7a13060cb2848c5bb8efa7c9f71cbac">GameEngine::Input::Keyboard::Key</a>   </td><td class="markdownTableBodyNone">Store the key which will be used to go left.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">key_down   </td><td class="markdownTableBodyNone"><a class="el" href="namespaceGameEngine_1_1Input_1_1Keyboard.html#ae7a13060cb2848c5bb8efa7c9f71cbac">GameEngine::Input::Keyboard::Key</a>   </td><td class="markdownTableBodyNone">Store the key which will be used to go down.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">key_right   </td><td class="markdownTableBodyNone"><a class="el" href="namespaceGameEngine_1_1Input_1_1Keyboard.html#ae7a13060cb2848c5bb8efa7c9f71cbac">GameEngine::Input::Keyboard::Key</a>   </td><td class="markdownTableBodyNone">Store the key which will be used to go right.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">speed   </td><td class="markdownTableBodyNone">float   </td><td class="markdownTableBodyNone">Speed to add to the velocity.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md6"></a>
MusicComponent</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">path   </td><td class="markdownTableBodyNone">std::string   </td><td class="markdownTableBodyNone">Path to the sound file.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">music   </td><td class="markdownTableBodyNone"><a class="el" href="classGameEngine_1_1Music.html" title="Class representing a music wrapper for sf::Music.">GameEngine::Music</a>   </td><td class="markdownTableBodyNone">Music to use.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md7"></a>
PressableComponent</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hitbox   </td><td class="markdownTableBodyNone">GameEngine::Rect&lt;int&gt;   </td><td class="markdownTableBodyNone">Rectangle for the hitbox of the pressable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">textureDefault   </td><td class="markdownTableBodyNone">GameEngine::Rect&lt;int&gt;   </td><td class="markdownTableBodyNone">Rectangle for the default state of the button. The texture needs to be a spritesheet, and the rectangle diffines the place of the sprite in it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">textureHovered   </td><td class="markdownTableBodyNone">GameEngine::Rect&lt;int&gt;   </td><td class="markdownTableBodyNone">Rectangle for the hovered state of the button, will trigger when the mouse is on the button but the button isn't pressed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">texturePressed   </td><td class="markdownTableBodyNone">GameEngine::Rect&lt;int&gt;   </td><td class="markdownTableBodyNone">Rectangle for the pressed state of the button.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">state   </td><td class="markdownTableBodyNone"><a class="el" href="namespaceGameEngine.html#a544162029bd9ec1abb8112bf7d3719f2">GameEngine::PressableState</a>   </td><td class="markdownTableBodyNone">Enum which will be used to tell the state of the button.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">action   </td><td class="markdownTableBodyNone">std::function&lt;void()&gt;   </td><td class="markdownTableBodyNone">Function for the callback of the button when pressed. Can store a lambda, which call another function with different parameters   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md8"></a>
TextComponent</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">str   </td><td class="markdownTableBodyNone">std::string   </td><td class="markdownTableBodyNone">String for the text.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">std::size_t   </td><td class="markdownTableBodyNone">Size of the text.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">text   </td><td class="markdownTableBodyNone"><a class="el" href="classGameEngine_1_1Text.html" title="Class representing a text wrapper for sf::Text with basic functionality.">GameEngine::Text</a>   </td><td class="markdownTableBodyNone">Text class which will be rendered.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">isRendered   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Tells whether the text should be rendered or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">renderLayer   </td><td class="markdownTableBodyNone">std::size_t   </td><td class="markdownTableBodyNone">Priority for the rendering of the text, the lowest layer is render first.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md9"></a>
TextureComponent</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">texture   </td><td class="markdownTableBodyNone"><a class="el" href="classGameEngine_1_1Texture.html" title="Class representing a texture wrapper for sf::Texture with an associated area.">GameEngine::Texture</a>   </td><td class="markdownTableBodyNone">Texture for the sprite.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sprite   </td><td class="markdownTableBodyNone"><a class="el" href="classGameEngine_1_1Sprite.html" title="Class representing a sprite wrapper for sf::Sprite with additional functionality.">GameEngine::Sprite</a>   </td><td class="markdownTableBodyNone">Sprite of the texture.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">animated   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Tells if the texture is animated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">textureRects   </td><td class="markdownTableBodyNone">std::vector&lt;GameEngine::Rect&lt;int&gt;&gt;   </td><td class="markdownTableBodyNone">Rectangle deffining the different state of the animation in the texture.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">animationSpeed   </td><td class="markdownTableBodyNone">float   </td><td class="markdownTableBodyNone">Speed of the update for the animation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">isRendered   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Tells whether the texture should be rendered or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lastUpdate   </td><td class="markdownTableBodyNone">float   </td><td class="markdownTableBodyNone">Last update of the texture.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">animeId   </td><td class="markdownTableBodyNone">std::size_t   </td><td class="markdownTableBodyNone">Index of the animation in the vector.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">renderLayer   </td><td class="markdownTableBodyNone">std::size_t   </td><td class="markdownTableBodyNone">Priority for the rendering of the text, the lowest layer is render first.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md10"></a>
TransformComponent</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">position   </td><td class="markdownTableBodyNone">GameEngine::Vector2&lt;float&gt;   </td><td class="markdownTableBodyNone">Position of the entity.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">velocity   </td><td class="markdownTableBodyNone">GameEngine::Vector2&lt;float&gt;   </td><td class="markdownTableBodyNone">Velocity of the entity.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md11"></a>
Systems</h2>
<p>The systems can be functions, lambdas or classes which implements the <code>operator()</code> overload. They can take <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>s as parameter, and they will be automatically be passed when you register them using the <code>addSystem</code> method of the registry. To use your added systems in the game loop, call the <code>runSystems</code> method of the registry. Systems will be called in the same order as when they were added. Example of a system addition and run : </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">GameEngine::PositionSystem positionSystem(_gameEngine.deltaTime.getDeltaTime());</div>
<div class="line"> </div>
<div class="line">gameEngine.registry.addSystem&lt;std::function&lt;void(SparseArray&lt;GameEngine::TransformComponent&gt; &amp;, SparseArray&lt;GameEngine::TextureComponent&gt; &amp;)&gt;,</div>
<div class="line">GameEngine::TransformComponent, GameEngine::TextureComponent&gt;(positionSystem);</div>
<div class="line"> </div>
<div class="line">// Game loop</div>
<div class="line">while (1)</div>
<div class="line">    gameEngine.registry.runSystems();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
AnimationSystem</h3>
<p>This system will handle the animation of the texture. The class takes a reference to the DeltaTime and the method that overload the <code>operator()</code> takes as parameter the <code>TextureComponent</code>'s <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
CollisionSystem</h3>
<p>This system calls all the callback functions contained in the <code>CollisionComponent</code> if the collision is active. It takes as parameter the <code>CollisionComponent</code>'s <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
ControlSystem</h3>
<p>This system updates the velocity of the entity based on the inputs. It takes as parameter the <code>TransformComponent</code> and <code>ControllableComponent</code>'s <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
DrawSystem</h3>
<p>This system draws the entity texture and text on the screen based on the <code>renderLayer</code>. It takes as parameter the <code>TextComponent</code> and <code>TextureComponent</code>'s <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>. This system have to be register with the second method which takes an <code>std::shared_ptr</code> conataining the system class.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
PositionSystem</h3>
<p>This system updates the position of the entity based on the velocity and moves the entity's texture if the entity have one. It takes as parameter the <code>TransformComponent</code> and <code>TextureComponent</code>'s <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
PressableComponent</h3>
<p>This system updates the state of the pressable and calls the callback action if the button is pressed. It takes as parameter the <code>TransformComponent</code>, <code>TextureComponent</code> and <code>PressableComponent</code>'s <code><a class="el" href="classSparseArray.html" title="Array which can have empty indexes.">SparseArray</a></code>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Game engine</h1>
<p>The game engine class is a class containing all the classes that the game needs.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
EventManager</h2>
<p>Class managing events to comunicate in the game engine. Each event can have one or more callbacks that will be called when the event is published.</p>
<p>Each event types are described in the <code>Event</code> enum with the type <code>EventType</code>.</p>
<p>An <code>EventHandler</code> is a class that manages the callbacks of one specific event.</p>
<p>When the user want to use the event system, it needs to instantiate an <code>EventManager</code> and then use the <code>addHandler</code> method to add an handler (<code>EventHandler</code>) for each event that he wants to use.</p>
<p>The <code>addHandler</code> method take as template the type of the data that will be passed to the callbacks when the event is published and as parameter the type of the event that will be managed.</p>
<p>Event handler exemple</p>
<div class="fragment"><div class="line"><span class="comment">// Create the event manager</span></div>
<div class="line">GameEngine::EventMananger eventManager;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a new event handler for the &#39;MyEvent&#39; event</span></div>
<div class="line">eventManager.addHandler&lt;<span class="keyword">struct </span>MyCallbackDataType&gt;(<a class="code" href="namespaceGameEngine.html">GameEngine</a>::Event::MyEvent);</div>
<div class="ttc" id="anamespaceGameEngine_html"><div class="ttname"><a href="namespaceGameEngine.html">GameEngine</a></div><div class="ttdef"><b>Definition:</b> AssetManager.hpp:15</div></div>
</div><!-- fragment --><p>To add a callback to an event the user must get the handler of the event and then use the <code>subscribe</code> methode and give the callback function. The callback function must take as parameter the type given in the template of the addHandler methode.</p>
<p>Add event callback exemple</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myCallback(<span class="keyword">struct</span> MyCallbackDataType)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Do something</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the handler of the event</span></div>
<div class="line"><a class="code" href="classGameEngine_1_1EventHandler.html">GameEngine::EventHandler&lt;struct MyCallbackDataType&gt;</a> myHandler =  eventManager.getHandler&lt;<span class="keyword">struct </span>MyCallbackDataType&gt;(<a class="code" href="namespaceGameEngine.html">GameEngine</a>::Event::MyEvent)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add a callback function</span></div>
<div class="line">myHandler.subscribe(myCallback);</div>
<div class="line">MyCallbackDataType</div>
<div class="ttc" id="aclassGameEngine_1_1EventHandler_html"><div class="ttname"><a href="classGameEngine_1_1EventHandler.html">GameEngine::EventHandler</a></div><div class="ttdoc">class that store all the callback functions for a specific event type</div><div class="ttdef"><b>Definition:</b> Event.hpp:90</div></div>
</div><!-- fragment --><p>Then now if the user wants to call the callbacks of the event he must call the <code>publish</code> methode</p>
<p>Publish event exemple </p><div class="fragment"><div class="line"><span class="comment">// Pass the data to the callbacks</span></div>
<div class="line">myHandler.<a class="code" href="classGameEngine_1_1EventHandler.html#a085f6fff9072360a9e73a51a0aa42031">publish</a>(MyCallbackDataType());</div>
<div class="ttc" id="aclassGameEngine_1_1EventHandler_html_a085f6fff9072360a9e73a51a0aa42031"><div class="ttname"><a href="classGameEngine_1_1EventHandler.html#a085f6fff9072360a9e73a51a0aa42031">GameEngine::EventHandler::publish</a></div><div class="ttdeci">void publish(EventData eventData)</div><div class="ttdoc">call all the subscribed functions with the given eventData</div><div class="ttdef"><b>Definition:</b> Event.hpp:100</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Registry</h2>
<p>This is the Entity Component System described above.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
DeltaTime</h2>
<p>Class which handles the delta time, it needs to be update at the begininf of the game loop with the method <code>update</code>. To get the delta time, simply use the <code>getDeltaTime</code> method.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
SceneManager</h2>
<p>Class managing scenes for the game, the scene needs to inherit the <code>AScene</code> class, and is used to create all the entity of a scene when it is loaded.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Prefab manager</h1>
<p>When you're creating a new entity, you have two choices, creating the entity itself and then add its components or use prefabs.</p>
<p>Prefabs are stored components associated with a name. It has to be loaded from a json file before using it with the <code>PrefabMaanger::loadPrefabFromFile</code> and then can be created with the <code>PrefabMaanger::createEntityFromPrefab</code>.</p>
<p>./Prefab%20systax.md "Click here" to check to prefab syntax.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Game loop example</h1>
<div class="fragment"><div class="line"><a class="code" href="classGameEngine_1_1GameEngine.html">GameEngine::GameEngine</a> gameEngine();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register components and systems</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn entities and add the components</span></div>
<div class="line"><span class="comment">// Or</span></div>
<div class="line">gameEngine.sceneManager.registerScene(<span class="stringliteral">&quot;Game&quot;</span>, std::make_unique&lt;GameScene&gt;());</div>
<div class="line">gameEngine.sceneManager.loadScene(<span class="stringliteral">&quot;Game&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (gameEngine.window.isOpen()) {</div>
<div class="line">    gameEngine.deltaTime.update();</div>
<div class="line">    _gameEngine.registry.runSystems();</div>
<div class="line">}</div>
<div class="ttc" id="aclassGameEngine_1_1GameEngine_html"><div class="ttname"><a href="classGameEngine_1_1GameEngine.html">GameEngine::GameEngine</a></div><div class="ttdoc">Game engine class, will manage all the necessary classes for the game.</div><div class="ttdef"><b>Definition:</b> GameEngine.hpp:40</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
